package motherlode.base.api;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;
import net.minecraft.util.Identifier;
import net.fabricmc.api.ModInitializer;
import motherlode.base.MotherlodeBase;
import motherlode.base.api.resource.AssetsManager;
import motherlode.base.api.resource.function.AssetProcessor;
import motherlode.base.api.resource.function.AssetsGenerator;
import motherlode.base.api.resource.function.DataGenerator;
import motherlode.base.api.resource.function.DataProcessor;
import motherlode.base.api.worldgen.FeaturesManager;
import motherlode.base.impl.ClientRegisterImpl;
import motherlode.base.impl.ServerRegisterImpl;
import motherlode.base.impl.resource.AssetsManagerImpl;
import motherlode.base.impl.resource.builder.adapter.artifice.assets.ArtificeResourceBuilderAdapter;
import motherlode.base.impl.resource.builder.adapter.artifice.data.ArtificeDataPackBuilderAdapter;
import motherlode.base.impl.worldgen.FeaturesManagerImpl;
import com.swordglowsblue.artifice.api.Artifice;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.NotNull;

public final class Motherlode implements ModInitializer {
    public static final String MODID = "motherlode";
    private static final Logger LOGGER = LogManager.getLogger("Motherlode");

    @Override
    public void onInitialize() {
        MotherlodeInitEvents.MAIN.register(() -> {
            List<DataGenerator> data = AssetsManagerImpl.INSTANCE.getData();

            Artifice.registerDataPack(Motherlode.id("data_pack"), pack -> {
                pack.setDisplayName("Motherlode Data");
                pack.setDescription("Data pack generated by Motherlode Base.");

                data.forEach(consumer -> consumer.accept(new ArtificeDataPackBuilderAdapter(pack)));

                try {
                    pack.dumpResources("debug" + File.separator + "motherlode", "data");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
            AssetsManagerImpl.INSTANCE.removeDataProcessorList();
        });

        MotherlodeInitEvents.MAIN.register(FeaturesManagerImpl.INSTANCE::addFeatures);

        MotherlodeInitEvents.CLIENT.register(() -> {
            ClientRegisterImpl.INSTANCE.getClientTasks().forEach(Runnable::run);
            ClientRegisterImpl.INSTANCE.removeClientTaskList();
        });

        MotherlodeInitEvents.CLIENT.register(() -> {
            List<AssetsGenerator> assets = AssetsManagerImpl.INSTANCE.getAssets();

            Artifice.registerAssetPack(Motherlode.id("resource_pack"), pack -> {
                pack.setDisplayName("Motherlode Assets");
                pack.setDescription("Resource pack generated by Motherlode Base.");

                assets.forEach(consumer -> consumer.accept(new ArtificeResourceBuilderAdapter(pack)));

                try {
                    pack.dumpResources("debug" + File.separator + "motherlode", "assets");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });

            AssetsManagerImpl.INSTANCE.removeAssetProcessorList();
        });

        MotherlodeInitEvents.DEDICATED_SERVER.register(() -> {
            ServerRegisterImpl.INSTANCE.getServerTasks().forEach(Runnable::run);
            ServerRegisterImpl.INSTANCE.removeServerTaskList();
        });

        // DEBUG
        /*
        getLogger().log(Level.WARN, "[Motherlode] Some debug tests are enabled. If you see this message and this is not in a development environment, please report this to the Motherlode team.");

        WoodType testWoodType = new WoodType(id(MotherlodeBase.MODID, "test"), MapColor.OAK_TAN, MapColor.SPRUCE_BROWN, (BlockState log, BlockState leaves) -> new DefaultSaplingGenerator(id(MotherlodeBase.MODID, "test_tree"),
            Feature.TREE.configure(new TreeFeatureConfig.Builder(new SimpleBlockStateProvider(log), new StraightTrunkPlacer(4, 2, 0), new SimpleBlockStateProvider(leaves), new SimpleBlockStateProvider(Blocks.OAK_SAPLING.getDefaultState()),
                new BlobFoliagePlacer(ConstantIntProvider.create(2), ConstantIntProvider.create(0), 3), new TwoLayersFeatureSize(1, 0, 1)).ignoreVines().build()))).register();
        */
    }

    /**
     * Logs the given message and module in the format {@code [Module] Message}.
     *
     * @param level   The severity level of the log message.
     * @param module  The (human-readable) name of the module that logs this message.
     * @param message The message to log.
     */
    public static void log(Level level, String module, CharSequence message) {
        getLogger().log(level, "[" + module + "] " + message);
    }

    /**
     * Logs the given message and module in the format {@code [Module] Message}.
     *
     * @param level   The severity level of the log message.
     * @param module  The (human-readable) name of the module that logs this message.
     * @param message The object to log. The {@code toString} method of the object will be used to get the actual message (or {@code null} if the object is null).
     */
    public static void log(Level level, String module, Object message) {
        getLogger().log(level, "[" + module + "] " + message);
    }

    /**
     * Returns a {@link Logger} instance for Motherlode.
     *
     * @return A logger.
     */
    public static Logger getLogger() {
        return LOGGER;
    }

    /**
     * Registers something.
     *
     * @param registerable The {@link Registerable} used to register the thing.
     * @param id           The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t            The thing to register.
     * @param <T>          The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t) {
        return register(registerable, id, t, null, null, null, null);
    }

    /**
     * Registers something.
     *
     * @param registerable The {@link Registerable} used to register the thing.
     * @param id           The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t            The thing to register.
     * @param data         A {@link DataProcessor} that can be used to register data for the thing.
     * @param <T>          The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, DataProcessor data) {
        return register(registerable, id, t, null, null, null, data);
    }

    /**
     * Registers something.
     *
     * @param registerable The {@link Registerable} used to register the thing.
     * @param id           The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t            The thing to register.
     * @param assets       An {@link AssetProcessor} that can be used to register assets for the thing.
     * @param <T>          The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, AssetProcessor assets) {
        return register(registerable, id, t, null, null, assets, null);
    }

    /**
     * Registers something.
     *
     * @param registerable The {@link Registerable} used to register the thing.
     * @param id           The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t            The thing to register.
     * @param assets       An {@link AssetProcessor} that can be used to register assets for the thing.
     * @param data         A {@link DataProcessor} that can be used to register data for the thing.
     * @param <T>          The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, AssetProcessor assets, DataProcessor data) {
        return register(registerable, id, t, null, null, assets, data);
    }

    /**
     * Registers something.
     *
     * @param registerable   The {@link Registerable} used to register the thing.
     * @param id             The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t              The thing to register.
     * @param clientConsumer A {@link Consumer} that will be only be run on the client. The {@code Identifier id} will be passed to this.
     * @param <T>            The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Consumer<Identifier> clientConsumer) {
        return register(registerable, id, t, null, clientConsumer, null, null);
    }

    /**
     * Registers something.
     *
     * @param registerable   The {@link Registerable} used to register the thing.
     * @param id             The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t              The thing to register.
     * @param clientConsumer A {@link Consumer} that will be only be run on the client. The {@code Identifier id} will be passed to this.
     * @param data           A {@link DataProcessor} that can be used to register data for the thing.
     * @param <T>            The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Consumer<Identifier> clientConsumer, DataProcessor data) {
        return register(registerable, id, t, null, clientConsumer, null, data);
    }

    /**
     * Registers something.
     *
     * @param registerable   The {@link Registerable} used to register the thing.
     * @param id             The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t              The thing to register.
     * @param clientConsumer A {@link Consumer} that will be only be run on the client. The {@code Identifier id} will be passed to this.
     * @param assets         An {@link AssetProcessor} that can be used to register assets for the thing.
     * @param <T>            The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Consumer<Identifier> clientConsumer, AssetProcessor assets) {
        return register(registerable, id, t, null, clientConsumer, assets, null);
    }

    /**
     * Registers something.
     *
     * @param registerable   The {@link Registerable} used to register the thing.
     * @param id             The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t              The thing to register.
     * @param clientConsumer A {@link Consumer} that will be only be run on the client. The {@code Identifier id} will be passed to this.
     * @param assets         An {@link AssetProcessor} that can be used to register assets for the thing.
     * @param data           A {@link DataProcessor} that can be used to register data for the thing.
     * @param <T>            The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Consumer<Identifier> clientConsumer, AssetProcessor assets, DataProcessor data) {
        return register(registerable, id, t, null, clientConsumer, assets, data);
    }

    /**
     * Registers something.
     *
     * @param registerable The {@link Registerable} used to register the thing.
     * @param id           The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t            The thing to register.
     * @param p            A {@link Processor} that can be used to do something with the thing after it is registered.
     * @param <T>          The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Processor<? super T> p) {
        return register(registerable, id, t, p, null, null, null);
    }

    /**
     * Registers something.
     *
     * @param registerable The {@link Registerable} used to register the thing.
     * @param id           The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t            The thing to register.
     * @param p            A {@link Processor} that can be used to do something with the thing after it is registered.
     * @param data         A {@link DataProcessor} that can be used to register data for the thing.
     * @param <T>          The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Processor<? super T> p, DataProcessor data) {
        return register(registerable, id, t, p, null, null, data);
    }

    /**
     * Registers something.
     *
     * @param registerable The {@link Registerable} used to register the thing.
     * @param id           The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t            The thing to register.
     * @param p            A {@link Processor} that can be used to do something with the thing after it is registered.
     * @param assets       An {@link AssetProcessor} that can be used to register assets for the thing.
     * @param <T>          The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Processor<? super T> p, AssetProcessor assets) {
        return register(registerable, id, t, p, null, assets, null);
    }

    /**
     * Registers something.
     *
     * @param registerable The {@link Registerable} used to register the thing.
     * @param id           The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t            The thing to register.
     * @param p            A {@link Processor} that can be used to do something with the thing after it is registered.
     * @param assets       An {@link AssetProcessor} that can be used to register assets for the thing.
     * @param data         A {@link DataProcessor} that can be used to register data for the thing.
     * @param <T>          The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Processor<? super T> p, AssetProcessor assets, DataProcessor data) {
        return register(registerable, id, t, p, null, assets, data);
    }

    /**
     * Registers something.
     *
     * @param registerable   The {@link Registerable} used to register the thing.
     * @param id             The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t              The thing to register.
     * @param p              A {@link Processor} that can be used to do something with the thing after it is registered.
     * @param clientConsumer A {@link Consumer} that will be only be run on the client. The {@code Identifier id} will be passed to this.
     * @param <T>            The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Processor<? super T> p, Consumer<Identifier> clientConsumer) {
        return register(registerable, id, t, p, clientConsumer, null, null);
    }

    /**
     * Registers something.
     *
     * @param registerable   The {@link Registerable} used to register the thing.
     * @param id             The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t              The thing to register.
     * @param p              A {@link Processor} that can be used to do something with the thing after it is registered.
     * @param clientConsumer A {@link Consumer} that will be only be run on the client. The {@code Identifier id} will be passed to this.
     * @param data           A {@link DataProcessor} that can be used to register data for the thing.
     * @param <T>            The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Processor<? super T> p, Consumer<Identifier> clientConsumer, DataProcessor data) {
        return register(registerable, id, t, p, clientConsumer, null, data);
    }

    /**
     * Registers something.
     *
     * @param registerable   The {@link Registerable} used to register the thing.
     * @param id             The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t              The thing to register.
     * @param p              A {@link Processor} that can be used to do something with the thing after it is registered.
     * @param clientConsumer A {@link Consumer} that will be only be run on the client. The {@code Identifier id} will be passed to this.
     * @param assets         An {@link AssetProcessor} that can be used to register assets for the thing.
     * @param <T>            The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Processor<? super T> p, Consumer<Identifier> clientConsumer, AssetProcessor assets) {
        return register(registerable, id, t, p, clientConsumer, assets, null);
    }

    /**
     * Registers something.
     *
     * @param registerable   The {@link Registerable} used to register the thing.
     * @param id             The {@link Identifier} that will be passed to the {@code Registerable}, {@code AssetProcessor} and {@code DataProcessor}.
     * @param t              The thing to register.
     * @param p              A {@link Processor} that can be used to do something with the thing after it is registered.
     * @param clientConsumer A {@link Consumer} that will be only be run on the client. The {@code Identifier id} will be passed to this.
     * @param assets         An {@link AssetProcessor} that can be used to register assets for the thing.
     * @param data           A {@link DataProcessor} that can be used to register data for the thing.
     * @param <T>            The type of the thing.
     * @return The thing that was registered
     */
    public static <T> T register(@NotNull Registerable<?> registerable, Identifier id, T t, Processor<? super T> p, Consumer<Identifier> clientConsumer, AssetProcessor assets, DataProcessor data) {
        registerable.register(id);

        if (p != null) p.accept(t);
        if (clientConsumer != null) registerOnClient(id, clientConsumer);
        if (assets != null) getAssetsManager().addAssets(id, assets);
        if (data != null) getAssetsManager().addData(id, data);

        return t;
    }

    /**
     * Adds a task that will only be run on the client.
     *
     * @param id         The {@link Identifier} that will be passed to the {@code Consumer} when it runs.
     * @param clientTask The {@link Consumer} that will be run on the client.
     */
    public static void registerOnClient(Identifier id, Consumer<Identifier> clientTask) {
        runOnClient(() -> clientTask.accept(id));
    }

    /**
     * Adds a task that will only be run on the dedicated server.
     *
     * @param id         The {@link Identifier} that will be passed to the {@code Consumer} when it runs.
     * @param serverTask The {@link Consumer} that will be run on the dedicated server.
     */
    public static void registerOnDedicatedServer(Identifier id, Consumer<Identifier> serverTask) {
        runOnDedicatedServer(() -> serverTask.accept(id));
    }

    /**
     * Adds a task that will only be run on the client.
     *
     * @param clientTask The {@link Runnable} that will be run on the client.
     */
    public static void runOnClient(Runnable clientTask) {
        if (MotherlodeBase.isModuleInitializationDone())
            throw new IllegalStateException("Trying to add client task outside motherlode:init entry point.");

        ClientRegisterImpl.INSTANCE.addClientTask(clientTask);
    }

    /**
     * Adds a task that will only be run on a dedicated server.
     *
     * @param serverTask The {@link Runnable} that will be run on the dedicated server.
     */
    public static void runOnDedicatedServer(Runnable serverTask) {
        if (MotherlodeBase.isModuleInitializationDone())
            throw new IllegalStateException("Trying to add dedicated server task outside motherlode:init entry point.");

        ServerRegisterImpl.INSTANCE.addServerTask(serverTask);
    }

    /**
     * Returns an implementation of {@link AssetsManager}. Should only be called from a {@code motherlode:init} entry point.
     *
     * @return An implementation of {@code AssetsManager}
     * @throws IllegalStateException if not called from a {@code motherlode:init} entry point.
     */
    public static AssetsManager getAssetsManager() {
        if (MotherlodeBase.isModuleInitializationDone())
            throw new IllegalStateException("Trying to add assets outside motherlode:init entry point.");
        return AssetsManagerImpl.INSTANCE;
    }

    /**
     * Returns an implementation of {@link FeaturesManager}. Should only be called from a {@code motherlode:init} entry point.
     *
     * @return An implementation of {@code DataManager}
     * @throws IllegalStateException if not called from a {@code motherlode:init} entry point.
     */
    public static FeaturesManager getFeaturesManager() {
        if (MotherlodeBase.isModuleInitializationDone())
            throw new IllegalStateException("Trying to add data outside motherlode:init entry point.");
        return FeaturesManagerImpl.INSTANCE;
    }

    /**
     * Creates a new {@link Identifier} in the same namespace as an existing one, but with a different path.
     *
     * @param id       The existing {@code Identifier}. The namespace of this will become the new one's namespace.
     * @param function Function that takes the existing {@code Identifier}'s path and creates a new one.
     * @return An {@code Identifier} with the namespace of {@code id}, and with the path that {@code function} returns.
     */
    public static Identifier id(Identifier id, UnaryOperator<String> function) {
        return new Identifier(id.getNamespace(), function.apply(id.getPath()));
    }

    /**
     * Creates an {@link Identifier} from the given namespace and name.
     *
     * @param namespace The namespace to use for the {@code Identifier}.
     * @param name      The path to use for the {@code Identifier}.
     * @return The created {@code Identifier}
     * @deprecated Use {@code new Identifier} or {@link #id(Identifier, UnaryOperator)} instead.
     */
    @Deprecated
    public static Identifier id(String namespace, String name) {
        return new Identifier(namespace, name);
    }

    /**
     * Creates an {@link Identifier} using {@code motherlode} as the namespace.
     *
     * @param name The path to use for the {@code Identifier}.
     * @return The created {@code Identifier}
     */
    private static Identifier id(String name) {
        return new Identifier(MODID, name);
    }
}
